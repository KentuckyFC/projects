import pandas as pd 
from pymystem3 import Mystem #импортируем библиотеку pymystem3 для лематизации данных
from collections import Counter #импортируем библиотеку collections а из нее спец контейнер Counter
m = Mystem() #библиотеку объявим в этой переменной
data = pd.read_csv('/datasets/data.csv')
#data.info() #посмотрим на данные по фрейму
data.tail(100)#посмортим на сам фрейм с конца"
import warnings #отключим ошибки
warnings.filterwarnings('ignore')


# **Вывод** Из датафрейма следует, что перед нами таблица из 12 столбцов и большого числа строк.
# Уже на этом этапе мы видим, в колонках days_employed(общий трудовой стаж в днях) и total_income (ежемесячный доход) есть не только пропущенные значения, но и отрицательные значения, которые возникли, скорее всего по пичине сбоя.
# Эти значения предстоит обработать.
# Так же вероятно, что в датафрейме могут встретиться дубликаты. Эту теорию так же предстоит проверить"



# ## Шаг 2. Предобработка данных

# ### Обработка пропусков

# In[4]:


#data.isna().sum() #посчитаем пропуски в каждом столбце
data['days_employed'] = data['days_employed'].fillna(data['days_employed'].median()) #заменим пропуски на среднее значение по столбцу
data['total_income'] = data['total_income'].fillna(data['total_income'].median())#заменим пропуски на среднее значение по столбцу
data.isna().sum() #снова проверим. Все получилось, пустых значений нет

# **Вывод**
# Для подсчета пропусков мы испольуем метод isna + sum
# nподтвердилась теория о пропущенных значениях в колонках days_employed(общий трудовой стаж в днях) и total_income (ежемесячный доход) - обнаружены 2174строки.
# Таким образом в 10%-ах строк из предоставленного датафрейма есть пропущенные данные. они могли возникнуть по причине того, что:
# -ошибка в данных
# -человек не работает
# -человек работает не официально
# -человек является учредителем ООО, поэтому ни трудоустройства, ни ежемесячного дохода у него нет, лишь годовые дивиденды
# -человек студент без постоянной работы или без работы в целом
# Поскольку в столбцах всречается пропуск - их мы должны заменить, воспользуемся методом fillna: в ее аргументе, где нужно уазать то, на что меняем, укажем среднее значение по конкретному столбцу методом median()
# Убедимся, введя data.isna().sum(), что пустых значений больше нет



# ### Замена типа данных

# In[5]:


#display (data.head(100))
#display(data.min()) #посмортим отрицательные значения через min
data['children'] = abs(data['children']) #воспользуемся известным нам методом abs, который приводит все значания к модулю
data['days_employed'] = abs(data['days_employed']) #и здесь
data['days_employed']= data['days_employed'].apply(lambda x: x/365) #затем в этом столбце преобразуем дни в годы через apply
display(data.min())
display (data.head(100))



# **Вывод**
# Убедимся в том, что в таблице нет отрицательных значений методом .min(). Они, к ожалению есть: children -1, days_employed -18388.9
# Удалим отрицательные значения metodom abs()
# Сонва убедимся в том, что в таблице нет отрицательных значений методом .min(). Их более нет
# Общий трудовой стаж прописан в днях, запишем его в годах методом appply, чтобы было удобнее анализировать визуально.
# Особое внимание хотелось бы уделить ситуации с колонкой о детях... Я считаю, что -1 ребенок, это 1 ребенок из-за того, что это не минус, а тире и не 0.


# ### Обработка дубликатов

# In[6]:


data['education']=data['education'].str.lower()
data['family_status']=data['family_status'].str.lower()
data['income_type']=data['income_type'].str.lower()
data['gender']=data['gender'].str.lower()
data['purpose']=data['purpose'].str.lower()
#display (data.duplicated().sum()) #посмортим сколько явных дубликатов! их 71
#data[data.duplicated(keep=False)].sort_values(by=['total_income', 'days_employed'])# глазами оценим эти дубликаты. И правда, это дублирования, от них можно избавиться
data = data.drop_duplicates() #Избавимся от явных дубликатов известным нам методом
display (data.duplicated().sum()) #снова проверим как прошла чистка. Все прошло корректно. Дубликатов по сумме 0"


# **Вывод**

# Выведя фрейм на экран в предыдущем этапе, сразу обращаем внимание на ЗАГЛАВНЫЕ буквы в столбцах с категориальными значениями, далее это может нам помешать, ведь python будет видеть разные словаё6 если они написаны в разном регистре. Поэтому все столбцы, которые содержат такие значения приведем в строчную форму методом .str.lower().
# Методом .duplicated().sum() мы должны узнать есть ли в датафрейме дубликаты - есть, 71 штуки
# Посмотрим на них через data[data.duplicated(keep=False)].sort_values(), проанализировав, понимаем, что дубликаты реально существуют. Вызовем метод drop_duplicates() и избавимся от них, и затем снова проверим через display (data.duplicated().sum())
# Все дубликаты удалены

# ### Лемматизация

# In[7]:


text = m.lemmatize(' '.join(data['purpose']))
#print (lemmas)
#print(Counter(text)) #нашли частоту появления слов

def purpose_change(purpose):
    lemmas_row = m.lemmatize(purpose)
    if ('жилье' in lemmas_row or
        'недвижимость' in lemmas_row or 
       'недвижимости' in lemmas_row):
        return 'недвижимость'
    if 'автомобиль' in lemmas_row:
        return 'автомобиль'
    if 'свадьба' in lemmas_row:
        return 'свадьба'
    if 'образование' in lemmas_row:
        return 'образование'
    return 'иное'


data['purpose_new'] = data['purpose'].apply(purpose_change)  
display (data)



# In[ ]:


# **Вывод**text = data['purpose'].unique() нашли уник знач

# 

# ### Категоризация данных

# In[8]:


def total_income_cat(row):
    if row['total_income'] <= 50000:
        return 'низкий'
    elif 50000 < row['total_income'] <= 120000:
        return 'средний'
    elif 120000 < row['total_income'] < 1000000:
        return 'высокий'
    else:
        return 'высочайший'
    
    
def days_employed_cat(row):
    if row['days_employed'] <= 3652:
        return 'стаж до 10 лет'
    elif 3652 < row['days_employed'] <= 6904:
        return 'стаж 10-30 лет'
    else:
        return 'стаж от 30 лет'
        
        
def dob_years_cat(row):
    if row['dob_years'] < 30:
        return 'до 30 лет'
    elif 30 <= row['dob_years'] < 45:
        return '30-45 лет'
    elif 45 <= row['dob_years'] < 65:
        return '45-65 лет'
    else:
        return 'старше 65 лет'


def children_cat(row):
    if row['children'] == 0:
        return 'бездетные'
    elif 1 <= row['children'] <= 2:
        return '1-2 ребенка'
    else:
        return 'многодетные'
    
data['total_income_cat'] = data.apply(total_income_cat, axis=1)
data['days_employed_cat'] = data.apply(days_employed_cat, axis=1)
data['dob_years_cat'] = data.apply(dob_years_cat, axis=1)
data['children_cat'] = data.apply(children_cat, axis=1)
data


# Разобьем на категории на наше усмотрение
# ___________
# по 'total_income' - зарплата
# -'низкий' (<= 50000р.);
# -'средний' (50000 < x <= 120000);
# -'высокий' (120000 < x < 1000000);
# -'высочайший' (x >= 1000000);
# ___________
# по стажу ('days_employed'):
# -'до 10 лет';
# -'10-30 лет';
# -'от 30 лет';
# ___________
# по возрасту ('dob_years'):
# -'до 30 лет';
# -'30-45 лет';
# -'45-65 лет';
# -'более 65 лет';
# ___________
# по количеству детей ('children'):
# -'бездетные' (0 детей);
# -'1-2 ребенка';
# -'многодетные'(>= 3 детей);
# Затем напишем 4 функции: total_income_cat, days_employed_cat, dob_years_cat, children_cat
# Затем создадим новые столбцы в фрейме, куда сложим все категории, которым будет соответствовать клиент банка. Через Apply разумеется

# In[10]:

pd.qcut(data['total_income'], 5, ['низкий','ниже среднего','средний','выше среднего', 'высокий'])


# ## Шаг 3. Ответьте на вопросы

# - Есть ли зависимость между наличием детей и возвратом кредита в срок?

# In[11]:


def relation(category):# Создадим для расчета новую функцию
    return data.groupby(category)['debt'].mean().to_frame().sort_values(by='debt') #пусть она возвращает сгруппированные данные столбца"должники"
relation('children_cat')


# In[12]:

data.groupby('children_cat')['debt'].agg(['count', 'sum', lambda x: str(round(x.mean()*100,2)) +'%' ])


# In[13]:

data.groupby('children_cat')['debt'].agg(['count', 'sum', lambda x: '{:.2%} '.format(x.mean())])


# **Вывод**

# Да, зависимость есть. по нашему мнению, бездетные значительно реже остальных групп клиентов банка задерживают платеж по кредиту

# - Есть ли зависимость между семейным положением и возвратом кредита в срок?

# In[14]:


relation('family_status')


# In[15]:


dict(zip(data['family_status_id'], data['family_status']))


# In[16]:


# КОД РЕВЬЮЕРА

print('Создали словарь:')
family_dict = data[['family_status_id', 'family_status']]
family_dict = family_dict.drop_duplicates().reset_index(drop=True)
display(family_dict)


print('\n\nСгруппированная таблица. Берем по id, другой столбец удалили:')
a = data.groupby('family_status_id')['debt'].agg(['count', 'sum', lambda x: '{:.2%} '.format(x.mean())])
display(a)


# Заменяем
print('\n\nЗаменяем численные значения по ключу словаря:')
a.reset_index().replace({'family_status_id': family_dict.family_status.to_dict()})


# **Вывод**

# Клиенты банка, которые не состоят в отношениях или состоят в незарегистрированных отношениях более склонны к просрочке платежа по кредиту

# - Есть ли зависимость между уровнем дохода и возвратом кредита в срок?

# In[17]:


relation('total_income_cat')



# In[18]:


data.groupby( pd.qcut(data['total_income'], 5, ['низкий','ниже среднего','средний','выше среднего', 'высокий']) )['debt'].agg(['count', 'sum', lambda x: '{:.2%} '.format(x.mean())])


# **Вывод**

# Передадим в функцию столбец ('total_income_cat') и выявим, что люди, чей доход низкого класса меньше остальных склонны к просрочке платежа по кредиту

# - Как разные цели кредита влияют на его возврат в срок?

# In[19]:


relation('purpose_new')


# **Вывод**

# Проанализировав сведения о целях заемщиков, можно, прибегнув к функци выявить, что клиенты, взявшие кредит на автомобиль чаще остальных пропускают платеж; по кредиту
# А клиенты, которые берут кредит на недвижимость - наоборот, являются более надежными заемщиками

# ## Шаг 4. Общий вывод


# **Общий вывод**
# Семейное положенние влияет на вплатежеспособность по кредиту в срок, клиенты, бывший в браке чаще плятят в срок чем те, кто не бывали в браке(0.065 вероятности просрочки против 0.097 соответсвенно), причем разведенные и овдовевшие платят в срок чаще, чем остальные(вероятность задержки у разведенных и овдовевших самая низкая 0.065 ).
# 
# Так же, чем меньше детей, тем вероятнее взнос по кредиту в срок. Например у бездетных этот показатель равен 0.075, в то время как у семей с 1-2 детьми самый высокий риск задержки, он равен 0.092)
# 
# Так же стоит отметить, что клиенты, взявшие кредит на покупку недвижимости с наименьшей вероятностью из всех задержат платеж по кредиту, их поакзатель равен 0.072. В то время как кредит за машину платят в срок значительно реже, вероятность просрочки самая высокая - 0.093. С небольшим отрывом в антирейтинге следуют платежи по кредиту на образование - 0.092

